// Generated by LiveScript 1.6.0
(function(){
  var main;
  main = function(){
    this.que = [];
    this.running = false;
    this.bezierParam = [0.75, 0, 0.25, 1];
    return this;
  };
  main.intorder = ['number', 'color', 'numstr'];
  main.intparser = {
    number: function(vs, ve){
      if (!isNaN(vs)) {
        return [+s[k], +e[k]];
      } else {
        return null;
      }
    },
    numstr: function(vs, ve){
      if (typeof vs === 'string' && /\d+/.exec(vs)) {
        return [new NumStr(vs), new NumStr(ve)];
      } else {
        return null;
      }
    },
    color: function(vs, ve){
      if (!isNaN(ldColor.hsl(vs).a)) {
        return [ldColor.hsl(vs), ldColor.hsl(ve)];
      } else {
        return null;
      }
    }
  };
  main.intptr = {
    number: function(a, b, t){
      return (b - a) * t + a;
    },
    numstr: function(a, b, t){
      return NumStr.interpolate(a, b, t);
    },
    color: function(a, b, t){
      var ref$, c;
      ref$ = [ldColor.hsl(a), ldColor.hsl(b), {}], a = ref$[0], b = ref$[1], c = ref$[2];
      ['h', 's', 'l', 'a'].map(function(k){
        return c[k] = (b[k] - a[k]) * t + a[k];
      });
      return ldColor.web(c);
    }
  };
  main.prototype = import$(Object.create(Object.prototype), {
    bezier: function(t){
      return cubic.Bezier.y(cubic.Bezier.t(t, this.bezierParam), this.bezierParam);
    },
    handler: function(t){
      var this$ = this;
      this.running = true;
      this.que.map(function(n){
        var ref$, vs, ve, tp, st, dur, percent, k, v, that, results$ = [];
        if (!n.a.st) {
          n.a.st = t;
        }
        ref$ = n.a, vs = ref$.vs, ve = ref$.ve, tp = ref$.tp, st = ref$.st, dur = ref$.dur;
        n.a.percent = percent = this$.bezier((ref$ = (t - st) / dur) < 1 ? ref$ : 1);
        for (k in vs) {
          v = vs[k];
          v = (that = main.intptr[tp[k]])
            ? that(vs[k], ve[k], percent)
            : ve[k];
          results$.push(n.n.setAttribute(k, v));
        }
        return results$;
      });
      this.que = this.que.filter(function(it){
        return it.a.percent < 1;
      });
      if (this.que.length) {
        return requestAnimationFrame(function(it){
          return this$.handler(it);
        });
      } else {
        return this.running = false;
      }
    },
    animate: function(n, ve, dur){
      var ref$, vs, tp, k, v, i$, len$, t, ret, a;
      dur == null && (dur = 333);
      ref$ = [{}, {}], vs = ref$[0], tp = ref$[1];
      for (k in ve) {
        v = ve[k];
        vs[k] = n.getAttribute(k);
        for (i$ = 0, len$ = (ref$ = main.intorder).length; i$ < len$; ++i$) {
          t = ref$[i$];
          if (!(ret = main.intparser[t](vs[k], ve[k]))) {
            continue;
          }
          tp[k] = t;
          break;
        }
      }
      a = {
        vs: vs,
        ve: ve,
        tp: tp,
        dur: dur,
        st: 0
      };
      if (!this.que.filter(function(it){
        return it.n === n;
      }).length) {
        return this.que.push({
          n: n,
          a: a
        });
      }
    },
    start: function(){
      var this$ = this;
      if (this.running) {
        return;
      }
      this.running = true;
      return requestAnimationFrame(function(it){
        return this$.handler(it);
      });
    }
  });
  if (typeof module != 'undefined' && module !== null) {
    module.exports = main;
  }
  if (typeof window != 'undefined' && window !== null) {
    window.transition = main;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
